<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Paragalaxy</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        * {box-sizing: border-box; margin: 0; padding: 0;}
        html, body {
            background-color: #000; color: #fff; font-family: 'Press Start 2P', cursive;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            image-rendering: pixelated;
        }
       
        #game-container {
            position: relative;
            background-color: #000;
            border: 5px solid #444;
            box-shadow: inset 0 0 20px #000;
            cursor: none;
            /* Sizing is handled by JavaScript to ensure it fits all viewports */
        }

        canvas {
            display: block; width: 100%; height: 100%;
            position: absolute; top: 0; left: 0; z-index: 1;
        }
       
        #crosshair {
            position: absolute; width: 30px; height: 30px; z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M14 0h2v10h-2z M14 20h2v10h-2z M0 14h10v2h-10z M20 14h10v2h-10z' fill='%23FFFF00'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: center center;
            pointer-events: none;
            transform: translate(-50%, -50%);
            top: 50%; left: 50%;
        }
       
        #cockpit-frame {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-style: solid;
            border-color: #282f67;
            border-width: 40px 75px;
            border-radius: 30px; box-shadow: inset 0 0 20px rgba(0,0,0,0.9);
            z-index: 2; pointer-events: none;
        }
        #cockpit-frame::before, #cockpit-frame::after {
            content: ''; position: absolute; background: #202652;
            width: 40px; height: 40px; box-shadow: inset 0 0 8px #000;
        }
        #cockpit-frame::before { top: -25px; left: -10px; transform: skewX(-45deg); }
        #cockpit-frame::after { top: -25px; right: -10px; transform: skewX(45deg); }

        #game-title-plate {
            position: absolute; top: 12px; left: 50%;
            transform: translateX(-50%);
            font-size: 1em; color: #aaa;
            background: #2a2a2a; border: 2px solid #111; padding: 4px 12px;
            border-radius: 4px; letter-spacing: 2px;
            text-shadow: 1px 1px 0 #000; box-shadow: inset 0 1px 3px #000;
            z-index: 4;
        }
       
        .dashboard { position: absolute; top: 40px; bottom: 40px; width: 65px; z-index: 3; }
        #left-dashboard { left: 5px; display: flex; flex-direction: column; }
        #right-dashboard { right: 5px; }
        .dash-light {
            width: 12px; height: 12px; border-radius: 50%; background-color: #222; border: 2px solid #111; box-shadow: inset 0 0 4px rgba(0,0,0,0.7); margin: 8px auto;
        }
        .dash-light.green {
            background-color: #0f0; box-shadow: 0 0 7px #0f0; animation: pulse-green 2s infinite ease-in-out;
        }
       
        #status-display {
            background: #111; border: 2px solid #444; margin: 0 auto 8px auto; padding: 4px;
            border-radius: 4px; box-shadow: inset 0 0 6px #000; text-align: center;
        }
        #status-display span {
            font-size: 6px; color: #ffff00; text-shadow: 1px 1px 0 #000;
            display: block; margin-bottom: 2px;
        }
        .status-bar-container {
            width: 100%; height: 10px; background: #1a1a1a; border: 1px solid #222;
            border-radius: 2px; padding: 1px; margin-bottom: 4px;
        }
        #shield-bar, #health-bar {
            width: 100%; height: 100%; border-radius: 1px;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        #shield-bar { background: #00BFFF; }
        #health-bar { background: #00FF00; }

        .dashboard-button-container {
            width: 40px; height: 30px; display: flex; justify-content: center; align-items: center;
            margin: 0 auto; cursor: pointer;
        }
        #sound-toggle, #pause-button {
            width: 24px; height: 24px;
        }

        .powerup-screen {
            width: 50px; height: 35px; background: #111; border: 2px solid #444;
            margin: 4px auto; border-radius: 4px; box-shadow: inset 0 0 6px #000;
            transition: all 0.3s ease; display: flex; justify-content: center;
            align-items: center; font-size: 8px; color: rgba(255, 85, 85, 0);
            text-shadow: 1px 1px 0 #000;
        }
        #powerup-screen.ready {
            background: #500; border-color: #f33; color: #fff;
            box-shadow: 0 0 12px #f00, inset 0 0 8px #f00;
            animation: pulse-red-text 1.5s infinite ease-in-out;
        }
        #nova-powerup-screen.ready {
             background: #005; border-color: #33f; color: #fff;
            box-shadow: 0 0 12px #00f, inset 0 0 8px #00f;
            animation: pulse-blue-text 1.5s infinite ease-in-out;
        }

        .dash-lever-track {
            width: 8px; height: 50px; background: #1a1a1a; border-radius: 4px; margin: 4px auto 8px auto; position: relative;
        }
        .dash-lever {
            position: absolute; left: -8px; bottom: 38px; width: 24px; height: 12px; border-radius: 2px; transition: bottom 0.3s ease;
            pointer-events: auto; /* Make sure levers are interactive */
        }
        #dash-lever { background: #d92121; border-top: 2px solid #ff5555; }
        #nova-lever { background: #2121d9; border-top: 2px solid #5555ff; }
        #dash-lever.ready-to-pull { animation: pulse-red 1s infinite; cursor: pointer!important; }
        #nova-lever.ready-to-pull { animation: pulse-blue 1s infinite; cursor: pointer!important; }
        .dash-lever.pulled { bottom: 4px; }
       
        #decorative-buttons { margin-top: auto; }
        .side-button-row { display: flex; justify-content: center; gap: 5px; margin-bottom: 6px;}
        .side-button { width: 10px; height: 10px; border-radius: 50%; background-color: #333; border: 1px solid #222; box-shadow: inset 0 1px 2px #000; }
        .side-button.green { background: #080; animation: pulse-green 3s infinite alternate;}
        .side-button.blue { background: #008; animation: pulse-blue 2.5s infinite alternate-reverse;}
        .switch-track { width: 12px; height: 24px; background-color: #1a1a1a; border-radius: 12px; border: 1px solid #111; position: relative; padding: 2px; }
        .switch-toggle { width: 8px; height: 8px; border-radius: 50%; background: #666; position: absolute; top: 2px; left: 2px; }

        #radar-screen { margin: 10px auto 0 auto; position: relative; width: 60px; height: 60px; background: radial-gradient(circle, #020 10%, #050 70%); border-radius: 50%; border: 2px solid #0a0; box-shadow: inset 0 0 8px #000; overflow: hidden; }
        #radar-sweep { width: 100%; height: 100%; background: linear-gradient(45deg, transparent 50%, rgba(50, 255, 50, 0.3) 50%); transform-origin: 50% 50%; animation: radar-sweep 3s linear infinite; }
        .radar-blip {
            position: absolute; width: 3px; height: 3px; background: #afa; border-radius: 50%; animation: pulse 1s infinite;
        }

        #scanlines-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%; z-index: 6;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.4; transform: scale(0.8); } }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 8px #f00; } 50% { box-shadow: 0 0 20px #ff5555, inset 0 0 5px #ffaaaa; } }
        @keyframes pulse-blue { 0%, 100% { box-shadow: 0 0 8px #00f; } 50% { box-shadow: 0 0 20px #5555ff, inset 0 0 5px #aaaaff; } }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 8px #0f0; } 50% { box-shadow: 0 0 20px #55ff55, inset 0 0 5px #aaffaa; } }
        @keyframes pulse-red-text { 0%, 100% { text-shadow: 0 0 2px #fff; transform: scale(1); } 50% { text-shadow: 0 0 10px #ffaaaa; transform: scale(1.05); } }
        @keyframes pulse-blue-text { 0%, 100% { text-shadow: 0 0 2px #fff; transform: scale(1); } 50% { text-shadow: 0 0 10px #aaaaff; transform: scale(1.05); } }
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 5px #ff0, 0 0 10px #ff0, 0 0 15px #ff0; }
            50% { text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #f90; }
        }
        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
        @keyframes radar-sweep { to { transform: rotate(360deg); } }

        #ui-overlay { position: absolute; top: 10px; left: 10px; width: calc(100% - 20px); display: flex; justify-content: space-between; align-items: center; pointer-events: none; z-index: 4; padding: 0 80px; font-size: 0.8em; color: #FFFF00; text-shadow: 2px 2px 0 #000; }
        #score-container { margin-right: auto; padding-right: 20px;} /* Pushed to the left */
        #level-container { margin-left: auto; padding-left: 20px; } /* Pushed to the right */
        #score-container, #level-container { position: relative; padding: 0 5px; }
        #score-container::before, #level-container::after { content: '['; position: absolute; left: -10px; }
        #score-container::after, #level-container::before { content: ']'; position: absolute; right: -10px; }

        .powerup-status-text { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); font-size: 1em; font-weight: bold; display: none; z-index: 4; text-align: center; text-shadow: 2px 2px 0 #000; }
        #powerup-status { color: #FFA500; }
        #nova-powerup-status { color: #5555FF; top: 70px;}

        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 7; display: none; cursor: default; }
        .modal-content {
            background: #112266; padding: 20px 30px; border-radius: 8px; border: 4px solid #6677CC; box-shadow: 0 6px 0 #334499, 0 8px 15px rgba(0,0,0,0.5); max-width: 90%;
        }
        .modal h1 {
            color: #00FFFF; margin-bottom: 10px; font-size: 1.5em;
        }
        .modal p { font-size: 0.8em; margin-bottom: 20px; line-height: 1.5; max-width: 40ch; }
        .modal h2 { font-size: 1em; color: #FFFF00; margin-bottom: 20px;}
        .modal button {
            padding: 10px 20px; font-size: 1em; cursor: pointer; background-color: #33FF33; border: none; color: #fff; border-radius: 8px; font-family: 'Press Start 2P', cursive; border-bottom: 4px solid #00CC00; margin: 5px;
        }
        .modal button:active { transform: translateY(2px); border-bottom-width: 2px; }
        .modal button.secondary {
            background-color: #FFB800; border-bottom-color: #CC8400;
        }
        .modal button.danger {
            background-color: #FF3333; border-bottom-color: #CC0000;
        }
        .modal button:disabled {
            background-color: #999;
            border-bottom-color: #666;
            cursor: not-allowed;
            transform: translateY(0);
        }
        #high-score-notice {
            color: #FFFF00;
            font-size: 1em;
            margin-top: 15px;
            animation: glow 1.5s infinite ease-in-out;
            display: none;
        }
       
        #bottom-dashboard-decoration { position: absolute; bottom: 0; left: 75px; right: 75px; height: 38px; z-index: 3; pointer-events: none; padding: 5px 10px; display: flex; justify-content: space-between; align-items: flex-end; }
        .deco-panel { display: flex; flex-direction: column; gap: 4px; }
        .deco-light-strip { display: flex; gap: 2px; background-color: #111; padding: 3px; border-radius: 3px; border: 1px solid #000; }
        .deco-light { width: 6px; height: 12px; background-color: #333; border-radius: 2px; box-shadow: inset 0 1px 1px #000; }
        .deco-light.yellow { background-color: #880; animation: flicker 0.2s infinite alternate; }
        .deco-light.red { background-color: #800; animation: pulse-red 2s infinite; }
        .deco-button-group { display: flex; gap: 4px; margin-top: 4px; }
        .deco-button { width: 16px; height: 16px; background-image: linear-gradient(to bottom, #444, #333); border: 1px solid #222; box-shadow: 0 2px 0 #111;}
        .deco-button.round { border-radius: 50%; }
        .deco-button.square { border-radius: 3px; }
        .deco-button.green-glow { background-image: linear-gradient(to bottom, #484, #363); animation: pulse-green 4s infinite;}


        #controls-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: space-between; align-items: flex-end; padding: 20px; z-index: 10; pointer-events: none; }
        #joystick-container, #fireButton { pointer-events: auto; }
        #joystick-container { width: 120px; height: 120px; background-color: rgba(50, 50, 50, 0.5); border-radius: 50%; border: 4px solid #888; position: relative; display: flex; justify-content: center; align-items: center; }
        #joystick-knob { width: 60px; height: 60px; background: radial-gradient(circle, #999 0%, #666 100%); border: 3px solid #444; border-radius: 50%; position: absolute; cursor: grab; box-shadow: 0 4px 0 #333; }
        
        #fireButton {
            width: 100px;
            height: 100px;
            background-image: radial-gradient(circle, #f54e4e 0%, #d11a2a 100%);
            color: white;
            font-size: 1.3em;
            font-weight: bold;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            user-select: none;
            text-shadow: 2px 2px 0 #880814;
            box-shadow: 0 6px 0 #a0101d, inset 0 2px 3px rgba(255,255,255,0.4);
            transition: all 0.05s ease;
            display:flex;
            justify-content:center;
            align-items:center;
        }
        #fireButton:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #a0101d, inset 0 2px 3px rgba(255,255,255,0.4);
        }
       
        #rotate-device-screen {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: #000; /* MODIFIED: Set to solid black */
            z-index: 1000;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
            padding: 20px;
            color: #fff;
            text-shadow: 0 0 8px #fff;
        }
        
        /* NEW */
        #rotate-screen-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place behind the text */
        }
        
        @media(hover: none) and (orientation: landscape) {
            #controls-container { display: flex; }
            #joystick-container { width: 22vmin; height: 22vmin; }
            #joystick-knob { width: 11vmin; height: 11vmin; }
            #fireButton { width: 20vmin; height: 20vmin; font-size: 2.5vmin; }
        }
        @media(hover: none) and (orientation: portrait) {
            #rotate-device-screen { display: flex; }
        }
    </style>
</head>
<body>
    <div id="rotate-device-screen">
        <canvas id="rotate-screen-canvas"></canvas>
        <p>Please rotate your device</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair"></div>
        <div id="cockpit-frame"></div>
        <div id="game-title-plate">PARAGALAXY</div>

        <!-- LEFT DASHBOARD -->
        <div id="left-dashboard" class="dashboard">
            <div id="status-display">
                <span>SHIELD</span>
                <div class="status-bar-container"><div id="shield-bar"></div></div>
                <span>HEALTH</span>
                <div class="status-bar-container"><div id="health-bar"></div></div>
            </div>
            <div class="dashboard-button-container" title="Toggle Sound">
                <div id="sound-toggle"></div>
            </div>
            <div class="dashboard-button-container" title="Pause Game (P)">
                <div id="pause-button"></div>
            </div>
             <div id="decorative-buttons">
                <div class="side-button-row">
                    <div class="side-button green"></div>
                    <div class="side-button"></div>
                </div>
                <div class="side-button-row">
                     <div class="switch-track">
                        <div class="switch-toggle"></div>
                    </div>
                </div>
            </div>
            <div id="radar-screen"><div id="radar-sweep"></div><div id="radar-blips-container"></div></div>
        </div>
       
        <!-- RIGHT DASHBOARD -->
        <div id="right-dashboard" class="dashboard">
            <div class="dash-light green"></div>
            <div id="powerup-screen" class="powerup-screen"></div>
            <div class="dash-lever-track"><div id="dash-lever" class="dash-lever"></div></div>
            <div id="nova-powerup-screen" class="powerup-screen"></div>
            <div id="nova-lever-track" class="dash-lever-track"><div id="nova-lever" class="dash-lever"></div></div>
             <div class="side-button-row" style="margin-top: 15px;">
                <div class="side-button blue"></div>
                <div class="side-button"></div>
                <div class="side-button blue"></div>
            </div>
        </div>
       
        <!-- BOTTOM DASHBOARD DECORATION -->
        <div id="bottom-dashboard-decoration">
            <div class="deco-panel">
                <div class="deco-light-strip">
                    <div class="deco-light yellow"></div>
                    <div class="deco-light red"></div>
                    <div class="deco-light yellow"></div>
                </div>
                <div class="deco-button-group">
                    <div class="deco-button square green-glow"></div>
                    <div class="deco-button round"></div>
                </div>
            </div>
            <div class="deco-panel">
                 <div class="deco-light-strip" style="width: 120px; justify-content: center;">
                    <div class="deco-light red"></div>
                    <div class="deco-light"></div>
                    <div class="deco-light red"></div>
                    <div class="deco-light"></div>
                    <div class="deco-light red"></div>
                </div>
                <div class="deco-button-group">
                    <div class="deco-button square"></div>
                    <div class="deco-button square"></div>
                    <div class="deco-button round"></div>
                    <div class="deco-button round"></div>
                </div>
            </div>
            <div class="deco-panel">
                <div class="deco-light-strip">
                    <div class="deco-light yellow"></div>
                    <div class="deco-light red"></div>
                    <div class="deco-light yellow"></div>
                </div>
                <div class="deco-button-group">
                    <div class="deco-button round"></div>
                    <div class="deco-button square green-glow"></div>
                </div>
            </div>
        </div>


        <div id="scanlines-overlay"></div>
        <div id="ui-overlay">
            <div id="score-container">SCORE:<span id="scoreEl">0</span></div>
            <div id="level-container">LEVEL:<span id="levelEl">1</span></div>
        </div>
        <div id="powerup-status" class="powerup-status-text"></div>
        <div id="nova-powerup-status" class="powerup-status-text"></div>

        <div id="startScreen" class="modal">
            <div class="modal-content">
                <h1>PARAGALAXY</h1>
                <p id="start-screen-text">Let's Rock</p>
                <button id="mainStartButton">Start Game</button>
                <button id="howToPlayButton" class="secondary">How to Play</button>
            </div>
        </div>
        <div id="howToPlayScreen" class="modal">
            <div class="modal-content">
                <h1>PARAGALAXY</h1>
                <h2>How To Play</h2>
                <p>Use your mouse or the joystick to aim. The ship is fixed at the center.<br><br>Destroy all targets.Don't let them hit you!<br><br>Your shields recharge at the start of each level.</p>
                <button id="backToMenuButton">Continue</button>
            </div>
        </div>
        <div id="gameOverScreen" class="modal">
            <div class="modal-content">
                <h1 id="gameOverTitle">GAME OVER</h1>
                <p>FINAL SCORE: <span id="finalScoreEl">0</span></p>
                <p id="high-score-notice">NEW HIGH SCORE!</p>
                <button id="restartButton" class="danger">RESTART</button>
            </div>
        </div>
        <div id="levelStartScreen" class="modal">
            <div class="modal-content">
                <h1 id="levelTitle">LEVEL 1</h1>
                <p id="levelObjective">Destroy all targets!</p>
                <button id="levelStartButton">START</button>
            </div>
        </div>
        <div id="pauseScreen" class="modal">
            <div class="modal-content">
                <h1>PAUSED</h1>
                <button id="resumeButton">RESUME</button>
            </div>
        </div>
    </div>

    <div id="controls-container">
        <div id="joystick-container"><div id="joystick-knob"></div></div>
        <button id="fireButton">SHOOT</button>
    </div>

    <script>
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d'), gameContainer = document.getElementById('game-container');
    const cockpitFrameEl = document.getElementById('cockpit-frame');
    const crosshairEl = document.getElementById('crosshair'), radarBlipsContainer = document.getElementById('radar-blips-container');
    const scoreEl = document.getElementById('scoreEl'), levelEl = document.getElementById('levelEl'), finalScoreEl = document.getElementById('finalScoreEl');
    const powerupStatusEl = document.getElementById('powerup-status'), soundToggle = document.getElementById('sound-toggle');
    const startScreen = document.getElementById('startScreen'), howToPlayScreen = document.getElementById('howToPlayScreen'), gameOverScreen = document.getElementById('gameOverScreen'), levelStartScreen = document.getElementById('levelStartScreen');
    const mainStartButton = document.getElementById('mainStartButton'), howToPlayButton = document.getElementById('howToPlayButton'), backToMenuButton = document.getElementById('backToMenuButton');
    const gameOverTitle = document.getElementById('gameOverTitle'), restartButton = document.getElementById('restartButton'), levelTitleEl = document.getElementById('levelTitle');
    const levelObjectiveEl = document.getElementById('levelObjective'), levelStartButton = document.getElementById('levelStartButton');
    const dashLeverEl = document.getElementById('dash-lever'), powerupScreenEl = document.getElementById('powerup-screen');
    const novaLeverEl = document.getElementById('nova-lever'), novaPowerupScreenEl = document.getElementById('nova-powerup-screen'), novaPowerupStatusEl = document.getElementById('nova-powerup-status');
    const startScreenText = document.getElementById('start-screen-text');
    const healthBarEl = document.getElementById('health-bar'), shieldBarEl = document.getElementById('shield-bar');
    const highScoreNoticeEl = document.getElementById('high-score-notice');
    const pauseButton = document.getElementById('pause-button'), pauseScreen = document.getElementById('pauseScreen'), resumeButton = document.getElementById('resumeButton');
    const rotateDeviceScreen = document.getElementById('rotate-device-screen');

    const soundOnIcon=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#FFFF00"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`;
    const soundOffIcon=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#888"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`;
    const pauseIcon=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#FFFF00"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
    const playIcon=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#FFFF00"><path d="M8 5v14l11-7z"/></svg>`;
   
    const GITHUB_BASE_URL = "https://cmstewardjr.github.io/Paragalaxy/";
    const enemyImageSources = {
        debris1: `${GITHUB_BASE_URL}Space%20Debris%201.png`,
        debris2: `${GITHUB_BASE_URL}Space%20Debris%202.png`,
        debris3: `${GITHUB_BASE_URL}Space-Debris%203.png`,
        asteroid1: `${GITHUB_BASE_URL}asteriod%201.png`,
        asteroid2: `${GITHUB_BASE_URL}asteriod%202.png`,
        asteroid3: `${GITHUB_BASE_URL}asteriod%203.png`,
        ship1: `${GITHUB_BASE_URL}Spaceship%201.png`,
        ship2: `${GITHUB_BASE_URL}Spaceship%202.png`,
        ship3: `${GITHUB_BASE_URL}Spaceship%203.png`,
        ufo1: `${GITHUB_BASE_URL}UFO%201.png`,
        ufo2: `${GITHUB_BASE_URL}UFO%202.png`,
        ufo3: `${GITHUB_BASE_URL}UFO%203.png`
    };

    const audioFiles = {
        shoot: `${GITHUB_BASE_URL}laser-gun-81720.mp3`,
        shoot_nova: `${GITHUB_BASE_URL}laser-zap-2-90669.mp3`,
        explosion: `${GITHUB_BASE_URL}explosion-fx-343683.mp3`
    };
    
    const explosionAnimationSources = {
        general: `${GITHUB_BASE_URL}explosion%20animation.png`,
        asteroid: `${GITHUB_BASE_URL}asteriod%20explosion%20animate.png`
    };

    const enemyImages = {};
    let explosionImage, asteroidExplosionImage;

    function createPlaceholderImage() {
        const tempCanvas = document.createElement('canvas'); tempCanvas.width = 64; tempCanvas.height = 64;
        const tempCtx = tempCanvas.getContext('2d'); tempCtx.fillStyle = '#FF00FF'; tempCtx.fillRect(0, 0, 64, 64);
        const placeholderImg = new Image(); placeholderImg.src = tempCanvas.toDataURL(); return placeholderImg;
    }

    function preloadImages() {
        const enemyPromises = Object.keys(enemyImageSources).map(key => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => { enemyImages[key] = img; resolve(img); };
                img.onerror = () => { console.error(`Failed to load asset for: ${key}. Using placeholder.`); enemyImages[key] = createPlaceholderImage(); resolve(enemyImages[key]); };
                img.src = enemyImageSources[key];
            });
        });

        const explosionPromise = new Promise(resolve => {
            explosionImage = new Image();
            explosionImage.onload = resolve;
            explosionImage.onerror = () => { console.error("Failed to load general explosion animation."); resolve(); };
            explosionImage.src = explosionAnimationSources.general;
        });

        const asteroidExplosionPromise = new Promise(resolve => {
            asteroidExplosionImage = new Image();
            asteroidExplosionImage.onload = resolve;
            asteroidExplosionImage.onerror = () => { console.error("Failed to load asteroid explosion animation."); resolve(); };
            asteroidExplosionImage.src = explosionAnimationSources.asteroid;
        });
        
        return Promise.all([...enemyPromises, explosionPromise, asteroidExplosionPromise]);
    }
   
    let score, currentLevel, isGameOver, gameLoopId, enemies, projectiles, particles, animatedExplosions, enemySpawner, player, radarBlips, stars, leverProgressScore;
    let soundEnabled = true, leverReady = false, isNovaCutterReady = false;
    let streakScore = 0;
    let isPaused = false;
    let audioCtx, audioUnlocked = false, audioBuffers = {}, masterGainNode;
    let camera = { x: 0, y: 0 };
    let crosshairPos = { x: 0, y: 0 }; // Current position
    let crosshairTarget = { x: 0, y: 0 }; // Target position (from mouse or joystick)
    let joystickTargetPos = { x: 0, y: 0, active: false};
    const JOYSTICK_EASING = 0.25; // Slower, smoother joystick movement

    let dynamicPlayerSpeed;
    let speedIncreaseInterval = null;
    
    // NEW: Variables for rotate screen animation
    let rotateScreenCanvas, rotateScreenCtx, rotateScreenStars = [], rotateScreenShootingStars = [];
    let rotateScreenAnimationId = null;
    const ROTATE_STAR_COUNT = 300;
    const ROTATE_SHOOTING_STAR_COUNT = 5;


    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        masterGainNode = audioCtx.createGain();
        masterGainNode.gain.value = 0.40; // Master volume set to 40%
        masterGainNode.connect(audioCtx.destination);
    } catch(e) {
        console.error("Web Audio API is not supported in this browser");
    }

    const BASE_PLAYER_SPEED = 8.0;
    const FOCAL_LENGTH = 400, MAX_DEPTH = 1000, STAR_COUNT = 450;
    const POWERUP_DURATION = 15000, NOVA_CUTTER_DURATION = 10000;
    const LEVER_SCORE_INTERVAL = 550; // MODIFIED: Point requirement for Double Blaster
    const NOVA_LEVER_SCORE_STREAK = 900; // MODIFIED: Streak requirement for Nova Cutter
    const PLAYER_MAX_HEALTH = 15, PLAYER_MAX_SHIELD = 10;
    const MIN_STAR_RADIUS = 0.5; const MAX_STAR_RADIUS = 2.5; const MIN_ENEMY_DRAW_SIZE = 3;
   
    const PARALLAX_STRENGTH = 2.0;
    const CAMERA_EASING = 0.05;

    // Cockpit dimensions for clamping crosshair
    const COCKPIT_BORDER_TOP = 60;
    const COCKPIT_BORDER_BOTTOM = 60;
    const COCKPIT_BORDER_LEFT = 90;
    const COCKPIT_BORDER_RIGHT = 90;

    const levels = [
        {name:"Space Debris", objective: "Clear the debris field!", e:[
            { h: 1, r: 80,  p: 50,  d: 1, i: 'debris1', c: '#999999'},
            { h: 2, r: 120, p: 125, d: 2, i: 'debris2', c: '#999999'},
            { h: 3, r: 150, p: 200, d: 3, i: 'debris3', c: '#999999'}
        ]},
        { name: "Asteroid Field", objective: "Navigate the asteroids!", e:[
            { h: 2, r: 80,  p: 75,  d: 2, i: 'asteroid1', c: '#808080'},
            { h: 3, r: 120, p: 150, d: 3, i: 'asteroid2', c: '#808080'},
            { h: 4, r: 150, p: 250, d: 4, i: 'asteroid3', c: '#808080'}
        ]},
        { name: "Enemy Fleet", objective: "Destroy the enemy squadron!", e:[
            { h: 3, r: 80,  p: 100, d: 3, i: 'ship1', c: '#00FF00'},
            { h: 4, r: 100, p: 200, d: 4, i: 'ship2', c: '#00BFFF'},
            { h: 5, r: 140, p: 300, d: 5, i: 'ship3', c: '#FF4500'}
        ]},
        { name: "UFO Invasion", objective: "Repel the alien invasion!", e:[
            { h: 4, r: 90,  p: 150, d: 4, i: 'ufo1', c: '#ADFF2F'},
            { h: 5, r: 120, p: 250, d: 5, i: 'ufo2', c: '#7FFF00'},
            { h: 6, r: 160, p: 400, d: 6, i: 'ufo3', c: '#32CD32'}
        ]},
        { name: "Survival", objective: "Survive!", e:[
            { h: 1, r: 80,  p: 50,  d: 1, i: 'debris1', c: '#999999'},
            { h: 3, r: 120, p: 150, d: 3, i: 'asteroid2', c: '#808080'},
            { h: 4, r: 100, p: 200, d: 4, i: 'ship2', c: '#00BFFF'},
            { h: 5, r: 140, p: 300, d: 5, i: 'ship3', c: '#FF4500'},
            { h: 6, r: 160, p: 400, d: 6, i: 'ufo3', c: '#32CD32'}
        ]}
    ];

    function getHighScore() { return parseInt(localStorage.getItem('paragalaxyHighScore') || '0', 10); }
    function setHighScore(newScore) { localStorage.setItem('paragalaxyHighScore', newScore); }
   
    class Entity {
        constructor(x, y, z, radius, velocity) { this.x = x; this.y = y; this.z = z; this.radius = radius; this.velocity = velocity; this.visible = false; }
        project() {
            if (this.z <= -FOCAL_LENGTH) { this.visible = false; return; }
            this.visible = true;
            this.scale = FOCAL_LENGTH / (FOCAL_LENGTH + this.z);
            this.screenX = (this.x - camera.x) * this.scale + (canvas.width / 2);
            this.screenY = (this.y - camera.y) * this.scale + (canvas.height / 2);
            this.screenRadius = this.radius * this.scale;
        }
        update() {
            this.z -= dynamicPlayerSpeed;
            this.x += this.velocity.x; this.y += this.velocity.y; this.z += this.velocity.z; this.project();
        }
    }
    class Projectile extends Entity {
        constructor(x, y, z, radius, velocity, color, damage = 1) {
            super(x, y, z, radius, velocity);
            this.color = color;
            this.damage = damage;
            this.isNovaBeam = damage > 1;
        }
        draw() {
            if (!this.visible) return;
            if(this.isNovaBeam){
                ctx.save();
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }
            ctx.beginPath();
            ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            if(this.isNovaBeam){
                ctx.restore();
            }
        }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; this.z += this.velocity.z; this.project(); }
    }
    class Enemy extends Entity {
        constructor(x,y,z,r,v,h,p,d,shapeKey,c) { super(x, y, z, r, v); this.health = h; this.maxHealth = h; this.points = p; this.damage = d; this.shapeKey = shapeKey; this.particleColor = c; }
        draw() {
            if (!this.visible || !this.shapeKey) return;
            const img = enemyImages[this.shapeKey]; if (!img) return;
            const drawSize = Math.max(MIN_ENEMY_DRAW_SIZE, this.screenRadius * 2);
            ctx.drawImage(img, this.screenX - drawSize / 2, this.screenY - drawSize / 2, drawSize, drawSize);
            if (this.health < this.maxHealth) {
                const healthBarY = (this.screenY - drawSize / 2) - 10;
                const barWidth = drawSize; const barHeight = Math.max(2, 5 * this.scale);
                ctx.fillStyle = '#8B0000'; ctx.fillRect(this.screenX - barWidth / 2, healthBarY, barWidth, barHeight);
                ctx.fillStyle = '#0f0'; ctx.fillRect(this.screenX - barWidth / 2, healthBarY, barWidth * (this.health / this.maxHealth), barHeight);
            }
        }
        reset() {
            this.z = MAX_DEPTH; const scaleAtSpawn = FOCAL_LENGTH / (FOCAL_LENGTH + this.z);
            const worldWidth = canvas.width / scaleAtSpawn; const worldHeight = canvas.height / scaleAtSpawn;
            this.x = (Math.random() - 0.5) * worldWidth; this.y = (Math.random() - 0.5) * worldHeight; this.health = this.maxHealth;
        }
    }
    class Particle extends Entity {
        constructor(x,y,z,s,v,c) { super(x, y, z, s, v); this.color = c; this.alpha = 1; }
        update() { super.update(); this.velocity.x *= 0.98; this.velocity.y *= 0.98; this.alpha -= 0.02; }
        draw() { if (!this.visible) return; ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.fillRect(this.screenX, this.screenY, this.screenRadius, this.screenRadius); ctx.restore(); }
    }
    class AnimatedExplosion extends Entity {
        constructor(x, y, z, size, image, frameWidth, totalFrames) {
            super(x, y, z, 0, {x:0, y:0, z:0});
            this.size = size;
            this.image = image;
            this.frameWidth = frameWidth;
            this.frameHeight = image.height; 
            this.totalFrames = totalFrames;
            this.currentFrame = 0;
            this.animationSpeed = 2; 
            this.frameCount = 0;
            this.isDone = false;
        }
        update() {
            super.update();
            this.frameCount++;
            if (this.frameCount > this.animationSpeed) {
                this.frameCount = 0;
                this.currentFrame++;
                if (this.currentFrame >= this.totalFrames) {
                    this.isDone = true;
                }
            }
        }
        draw() {
            if (!this.visible || this.isDone || !this.image || this.image.width === 0) return;
            const sx = this.currentFrame * this.frameWidth;
            const drawSize = this.size * this.scale;
            ctx.drawImage(
                this.image,
                sx, 0,
                this.frameWidth, this.frameHeight,
                this.screenX - drawSize / 2, this.screenY - drawSize / 2,
                drawSize, drawSize
            );
        }
    }
    class Player {
        constructor() {
            this.isDoubleBlasterActive = false;
            this.powerUpTimer = 0;
            this.isNovaCutterActive = false;
            this.novaCutterTimer = 0;
            this.maxHealth = PLAYER_MAX_HEALTH;
            this.health = this.maxHealth;
            this.maxShield = PLAYER_MAX_SHIELD;
            this.shield = this.maxShield;
        }
        update() {
            if (isPaused) return;
            if (this.isDoubleBlasterActive) { this.powerUpTimer -= 16.6; if (this.powerUpTimer <= 0) this.deactivateDoubleBlaster()}
            if (this.isNovaCutterActive) { this.novaCutterTimer -= 16.6; if (this.novaCutterTimer <= 0) this.deactivateNovaCutter()}
        }
        takeDamage(amount) {
            if (isGameOver) return;
            playSound('damage');
            streakScore = 0;
            const shieldDamage = Math.min(this.shield, amount);
            this.shield -= shieldDamage;
            const remainingDamage = amount - shieldDamage;
            if (remainingDamage > 0) this.health -= remainingDamage;
            if (this.health <= 0) { this.health = 0; endGame(false); }
            updateUI();
        }
        recharge() { this.health = this.maxHealth; this.shield = this.maxShield; }
        activateDoubleBlaster() { playSound('powerup'); this.isDoubleBlasterActive = true; this.powerUpTimer = POWERUP_DURATION; powerupStatusEl.textContent = 'DOUBLE BLASTER!'; powerupStatusEl.style.display = 'block'; powerupScreenEl.textContent = 'ACTIVE'; }
        deactivateDoubleBlaster() { this.isDoubleBlasterActive = false; powerupStatusEl.style.display = 'none'; dashLeverEl.classList.remove('pulled'); powerupScreenEl.textContent = ''; }
        activateNovaCutter() { playSound('powerup'); this.isNovaCutterActive = true; this.novaCutterTimer = NOVA_CUTTER_DURATION; novaPowerupStatusEl.textContent = 'NOVA CUTTER!'; novaPowerupStatusEl.style.display = 'block'; novaPowerupScreenEl.textContent = 'ACTIVE';}
        deactivateNovaCutter() {this.isNovaCutterActive = false; novaPowerupStatusEl.style.display = 'none'; novaLeverEl.classList.remove('pulled'); novaPowerupScreenEl.textContent = '';}
    }

    async function preloadAudio() {
        if (!audioCtx) return;
        const promises = Object.entries(audioFiles).map(async ([key, url]) => {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBuffers[key] = audioBuffer;
            } catch (error) {
                console.error(`Failed to load or decode audio for: ${key}`, error);
            }
        });
        return Promise.all(promises);
    }

    async function init() {
        resizeGame();
        startScreenText.textContent = "Loading assets...";
        mainStartButton.disabled = true; howToPlayButton.disabled = true; highScoreNoticeEl.style.display = 'none';
        startScreen.style.display = 'flex';
        [gameOverScreen, levelStartScreen, howToPlayScreen, pauseScreen].forEach(s => s.style.display = 'none');
        if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null;
        if (enemySpawner) clearInterval(enemySpawner);
        if (speedIncreaseInterval) clearInterval(speedIncreaseInterval);
        dynamicPlayerSpeed = BASE_PLAYER_SPEED;

        score = 0; currentLevel = 0; streakScore = 0;
        isGameOver = false; isPaused = false;
        leverReady = false; isNovaCutterReady = false;
        leverProgressScore = 0;
        camera = { x: 0, y: 0 };
       
        try {
            await Promise.all([preloadImages(), preloadAudio()]);
            const highScore = getHighScore();
            startScreenText.innerHTML = `HIGH SCORE: ${highScore}<br><br>The cosmos is crawling with hazards. Your mission is to clear them out.`;
            mainStartButton.disabled = false; howToPlayButton.disabled = false;
            player = new Player(); enemies = []; projectiles = []; particles = []; animatedExplosions = []; radarBlips = []; stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({ x: (Math.random() - 0.5) * 4000, y: (Math.random() - 0.5) * 3000, z: Math.random() * MAX_DEPTH });
            }
            soundToggle.innerHTML = soundEnabled ? soundOnIcon : soundOffIcon;
            pauseButton.innerHTML = pauseIcon;

            dashLeverEl.classList.remove('ready-to-pull', 'pulled'); dashLeverEl.style.cursor = 'default';
            powerupScreenEl.classList.remove('ready'); powerupScreenEl.textContent = '';
            novaLeverEl.classList.remove('ready-to-pull', 'pulled'); novaLeverEl.style.cursor = 'default';
            novaPowerupScreenEl.classList.remove('ready'); novaPowerupScreenEl.textContent = '';
            updateUI();
            animateMenuBackground();
        } catch (error) {
            console.error("Critical error during init:", error);
            startScreenText.textContent = "Error initializing game. Please refresh.";
        }
    }

    function unlockAudio() { if (audioUnlocked || !soundEnabled || !audioCtx) return; if (audioCtx.state === 'suspended') audioCtx.resume(); audioUnlocked = true}
    
    function playSound(type) {
        if (!soundEnabled || !audioUnlocked || !audioCtx) return;

        if (audioBuffers[type]) {
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[type];
            source.connect(masterGainNode);
            source.start(0);
            return;
        }

        const n = audioCtx.currentTime;
        switch (type) {
            case 'hit': {
                const o= audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'square'; o.frequency.setValueAtTime(440, n); o.frequency.exponentialRampToValueAtTime(110, n + 0.15);
                g.gain.setValueAtTime(0.4, n); g.gain.exponentialRampToValueAtTime(1e-3, n + 0.15);
                o.connect(g); g.connect(masterGainNode); o.start(n); o.stop(n + 0.15);
                break;
            }
            case 'damage': {
                const o= audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sawtooth'; o.frequency.setValueAtTime(120, n); o.frequency.exponentialRampToValueAtTime(50, n + 0.2);
                g.gain.setValueAtTime(0.5, n); g.gain.exponentialRampToValueAtTime(1e-3, n + 0.2);
                o.connect(g); g.connect(masterGainNode); o.start(n); o.stop(n + 0.2);
                break;
            }
            case 'powerup': case 'gameOver': {
                const o= audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sawtooth'; g.gain.setValueAtTime(0.3, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.7);
                o.frequency.setValueAtTime(type === 'powerup' ? 220 : 440, n); o.frequency.exponentialRampToValueAtTime(type === 'powerup' ? 880 : 110, n + 0.7);
                o.connect(g); g.connect(masterGainNode); o.start(n); o.stop(n + 0.7);
                break;
            }
            case 'ui_confirm': {
                const o= audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sine'; o.frequency.setValueAtTime(523.25, n); o.frequency.exponentialRampToValueAtTime(783.99, n + 0.15);
                g.gain.setValueAtTime(0.2, n); g.gain.exponentialRampToValueAtTime(1e-3, n + 0.15);
                o.connect(g); g.connect(masterGainNode); o.start(n); o.stop(n + 0.2);
                break;
            }
            case 'lever_ready_1': { // Ascending arpeggio for Double Blaster
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'triangle';
                o.connect(g);
                g.connect(masterGainNode);
                const scheduleNote = (freq, startTime, duration) => {
                    o.frequency.setValueAtTime(freq, startTime);
                    g.gain.setValueAtTime(0.2, startTime);
                    g.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                };
                let time = n;
                scheduleNote(261.63, time, 0.2); time += 0.2; // C4
                scheduleNote(329.63, time, 0.2); time += 0.2; // E4
                scheduleNote(392.00, time, 0.2); time += 0.2; // G4
                scheduleNote(523.25, time, 0.6);             // C5
                o.start(n);
                o.stop(n + 2.5);
                break;
            }
            case 'lever_ready_2': { // More "serious" arpeggio for Nova Cutter
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sawtooth';
                o.connect(g);
                g.connect(masterGainNode);
                const scheduleNote = (freq, startTime, duration) => {
                    o.frequency.setValueAtTime(freq, startTime);
                    g.gain.setValueAtTime(0.2, startTime);
                    g.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                };
                let time = n;
                scheduleNote(220.00, time, 0.15); time += 0.15; // A3
                scheduleNote(261.63, time, 0.15); time += 0.15; // C4
                scheduleNote(329.63, time, 0.15); time += 0.15; // E4
                scheduleNote(440.00, time, 0.5);  time += 0.5;  // A4
                scheduleNote(329.63, time, 0.8);               // E4
                o.start(n);
                o.stop(n + 2.5);
                break;
            }
        }
    }

    function showLevelStartScreen() {
        if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null;
        if (currentLevel > 0) player.recharge();
        player.deactivateDoubleBlaster();
        player.deactivateNovaCutter();
        updateUI();

        if (speedIncreaseInterval) clearInterval(speedIncreaseInterval);
        dynamicPlayerSpeed = BASE_PLAYER_SPEED;

        const levelData = levels[currentLevel];
        levelTitleEl.textContent = `Level ${ currentLevel + 1}: ${ levelData.name}`;
        levelObjectiveEl.textContent = levelData.objective; levelStartScreen.style.display = 'flex';
    }

    function startGameLoop() {
        playSound('ui_confirm');
        levelStartScreen.style.display = 'none';
        isGameOver = false;

        // Survival Mode special conditions
        if (currentLevel === 4) {
            dynamicPlayerSpeed = BASE_PLAYER_SPEED * 1.5; // Faster initial speed
        }

        spawnEnemies();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        if (menuLoopId) cancelAnimationFrame(menuLoopId);
        menuLoopId = null;
        animate();

        if (currentLevel !== 4) { // No gradual speed increase in survival
            speedIncreaseInterval = setInterval(() => {
                if (!isPaused) dynamicPlayerSpeed += 0.75;
            }, 15000);
        }
    }

    function spawnEnemies() {
        if (enemySpawner) clearInterval(enemySpawner);
        const spawnInterval = 1500 - (currentLevel * 150);
        enemySpawner = setInterval(() => {
            if (isGameOver || isPaused || enemies.length > 20) return;
            const enemyList = levels[currentLevel].e;
            const eType = enemyList[Math.floor(Math.random() * enemyList.length)];
            const z = MAX_DEPTH; const scaleAtSpawn = FOCAL_LENGTH / (FOCAL_LENGTH + z);
            const worldWidth = canvas.width / scaleAtSpawn; const worldHeight = canvas.height / scaleAtSpawn;
            const x = (Math.random() - 0.5) * worldWidth + camera.x; const y = (Math.random() - 0.5) * worldHeight + camera.y;
            const v = { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2, z: (Math.random() - 0.5) };
            enemies.push(new Enemy(x, y, z, eType.r, v, eType.h, eType.p, eType.d, eType.i, eType.c));
        }, spawnInterval > 400 ? spawnInterval : 400);
    }

    function drawStars() {
        ctx.fillStyle = `rgba(255, 255, 255, 1)`;
        stars.forEach(star => {
            star.z -= dynamicPlayerSpeed * 0.5;
            if (star.z <= -FOCAL_LENGTH) { star.z = MAX_DEPTH; }
            const z_safe = FOCAL_LENGTH + star.z; if (z_safe <= 0) return;
            const scale = FOCAL_LENGTH / z_safe;
            const x = (star.x - camera.x) * scale + (canvas.width / 2);
            const y = (star.y - camera.y) * scale + (canvas.height / 2);
            const r = Math.min(MAX_STAR_RADIUS, Math.max(MIN_STAR_RADIUS, scale * 2.5));
            if (x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                ctx.globalAlpha = Math.min(1, scale * 1.5); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }
        });
        ctx.globalAlpha = 1;
    }
   
    let menuLoopId = null;
    function animateMenuBackground() {
        const isGameRunning = !isGameOver && startScreen.style.display === 'none' && levelStartScreen.style.display === 'none' && howToPlayScreen.style.display === 'none' && !isPaused;
        if(isGameRunning) {
            if(menuLoopId) cancelAnimationFrame(menuLoopId);
            menuLoopId = null;
            return;
        }
        menuLoopId = requestAnimationFrame(animateMenuBackground);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawStars();
    }


    function animate() {
        gameLoopId = requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Smoothly move crosshair towards its target position
        crosshairPos.x += (crosshairTarget.x - crosshairPos.x) * JOYSTICK_EASING;
        crosshairPos.y += (crosshairTarget.y - crosshairPos.y) * JOYSTICK_EASING;
       
        crosshairEl.style.left = `${crosshairPos.x}px`;
        crosshairEl.style.top = `${crosshairPos.y}px`;

        if (canvas.width > 0) {
            const targetCamX = (crosshairPos.x - canvas.width / 2) * PARALLAX_STRENGTH;
            const targetCamY = (crosshairPos.y - canvas.height / 2) * PARALLAX_STRENGTH;
            camera.x += (targetCamX - camera.x) * CAMERA_EASING;
            camera.y += (targetCamY - camera.y) * CAMERA_EASING;
        }
       
        drawStars();
        player.update();

        const allEntities = [...particles, ...projectiles, ...enemies, ...animatedExplosions];
        allEntities.sort((a, b) => b.z - a.z);
        allEntities.forEach(entity => { entity.update(); entity.draw(); });
       
        for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
            const enemy = enemies[eIndex];
            if (enemy.z <= 0) {
                if (enemy.screenX > 0 && enemy.screenX < canvas.width && enemy.screenY > 0 && enemy.screenY < canvas.height) {
                    player.takeDamage(enemy.damage);
                }
                enemy.reset(); continue;
            }
            if (!enemy.visible) continue;
            for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
                const proj = projectiles[pIndex];
                if (!proj.visible || Math.abs(proj.z - enemy.z) > 50) continue;
                const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                if (dist < enemy.radius + proj.radius) {
                    playSound('hit');
                    for (let j = 0; j < enemy.radius * 0.2; j++) particles.push(new Particle(proj.x, proj.y, proj.z, Math.random() * 2 + 1, { x:(Math.random() - 0.5) * 4,y: (Math.random() - 0.5) * 4,z: (Math.random() - 0.5) * 2}, enemy.particleColor));
                    enemy.health -= proj.damage;
                    projectiles.splice(pIndex, 1);
                    if (enemy.health <= 0) {
                        playSound('explosion');

                        // CHOOSE AND CREATE ANIMATED EXPLOSION
                        const explosionSize = enemy.radius * 2.5; 
                        let explosionSheet, frameWidth, totalFrames;
                        if (enemy.particleColor === '#999999' || enemy.particleColor === '#808080') {
                            explosionSheet = asteroidExplosionImage;
                            frameWidth = 64; // Assuming 320px width / 5 frames
                            totalFrames = 5;
                        } else {
                            explosionSheet = explosionImage;
                            frameWidth = 64; // Assuming 384px width / 6 frames
                            totalFrames = 6;
                        }
                        animatedExplosions.push(new AnimatedExplosion(enemy.x, enemy.y, enemy.z, explosionSize, explosionSheet, frameWidth, totalFrames));

                        score += enemy.points;
                        streakScore += enemy.points;

                        if (!player.isDoubleBlasterActive) leverProgressScore += enemy.points;
                        updateUI();
                        enemies.splice(eIndex, 1);
                        
                        const requiredLeverScore = currentLevel === 4 ? 300 : LEVER_SCORE_INTERVAL;
                        const requiredNovaScore = currentLevel === 4 ? 600 : NOVA_LEVER_SCORE_STREAK;

                        if (!leverReady && leverProgressScore >= requiredLeverScore) makeLeverReady(requiredLeverScore);
                        if (!isNovaCutterReady && streakScore >= requiredNovaScore) makeNovaLeverReady();
                    }
                    break;
                }
            }
        }
       
        projectiles = projectiles.filter(p => p.z < MAX_DEPTH + 200 && p.z > -FOCAL_LENGTH);
        particles = particles.filter(p => p.alpha > 0 && p.z > -FOCAL_LENGTH);
        animatedExplosions = animatedExplosions.filter(exp => !exp.isDone);
        enemies = enemies.filter(e => e.z > -FOCAL_LENGTH);
       
        if (currentLevel < levels.length -1) {
            const scoreForNextLevel = (currentLevel + 1) * 2400;
            if (score >= scoreForNextLevel) {
                currentLevel++;
                playSound('powerup');
                clearInterval(enemySpawner);
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
                showLevelStartScreen();
            }
        }
        updateRadar();
    }

    function makeLeverReady(scoreToSubtract) { playSound('lever_ready_1'); leverReady = true; leverProgressScore -= scoreToSubtract; dashLeverEl.classList.add('ready-to-pull'); dashLeverEl.style.cursor = 'pointer'; powerupScreenEl.classList.add('ready'); powerupScreenEl.textContent = 'CLICK'; dashLeverEl.addEventListener('click', pullLever); dashLeverEl.addEventListener('touchstart', pullLever, { passive: false }); }
    function pullLever(e) { e.preventDefault(); e.stopPropagation(); if (!leverReady) return; leverReady = false; dashLeverEl.classList.remove('ready-to-pull'); dashLeverEl.classList.add('pulled'); dashLeverEl.style.cursor = 'default'; powerupScreenEl.classList.remove('ready'); player.activateDoubleBlaster(); dashLeverEl.removeEventListener('click', pullLever); dashLeverEl.removeEventListener('touchstart', pullLever); }
   
    function makeNovaLeverReady() { playSound('lever_ready_2'); isNovaCutterReady = true; novaLeverEl.classList.add('ready-to-pull'); novaLeverEl.style.cursor = 'pointer'; novaPowerupScreenEl.classList.add('ready'); novaPowerupScreenEl.textContent = 'CLICK'; novaLeverEl.addEventListener('click', pullNovaLever); novaLeverEl.addEventListener('touchstart', pullNovaLever, { passive: false }); }
    function pullNovaLever(e) { e.preventDefault(); e.stopPropagation(); if (!isNovaCutterReady) return; isNovaCutterReady = false; streakScore = 0; novaLeverEl.classList.remove('ready-to-pull'); novaLeverEl.classList.add('pulled'); novaLeverEl.style.cursor = 'default'; novaPowerupScreenEl.classList.remove('ready'); player.activateNovaCutter(); novaLeverEl.removeEventListener('click', pullNovaLever); novaLeverEl.removeEventListener('touchstart', pullNovaLever); }

    function endGame(isWin) {
        isGameOver = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
        clearInterval(enemySpawner);
        if (speedIncreaseInterval) clearInterval(speedIncreaseInterval);
       
        finalScoreEl.textContent = score;
        const highScore = getHighScore();
        if (score > highScore) { setHighScore(score); highScoreNoticeEl.style.display = 'block'; }
        else { highScoreNoticeEl.style.display = 'none'; }
        gameOverTitle.textContent = isWin ? "VICTORY!" : "GAME OVER"; gameOverScreen.style.display = 'flex';
        playSound(isWin ? 'powerup' : 'gameOver');
        animateMenuBackground();
    }
    function updateUI() {
        if (!scoreEl || !player) return;
        scoreEl.textContent = score; levelEl.textContent = currentLevel + 1;
        const shieldPercent = (player.shield / player.maxShield) * 100; shieldBarEl.style.width = `${shieldPercent}%`;
        const healthPercent = (player.health / player.maxHealth) * 100; healthBarEl.style.width = `${healthPercent}%`;
        if (healthPercent > 60) healthBarEl.style.backgroundColor = '#00FF00';
        else if (healthPercent > 30) healthBarEl.style.backgroundColor = '#FFFF00';
        else healthBarEl.style.backgroundColor = '#FF0000';
    }
    function updateRadar() { if (Math.random() < 0.1) { if (radarBlips.length < 5 && enemies.length > 0) radarBlips.push({ id: 'blip' + Date.now(),life: 100});else if (radarBlips.length > 0) radarBlips.shift()} let bHTML = ''; radarBlips.forEach(b => { b.life--; if (b.life <= 0) return; if (!b.x) { b.x = Math.random() * 80 + 10; b.y = Math.random() * 80 + 10} bHTML +=`<div class="radar-blip" style="left:${b.x}%; top:${b.y}%"></div>`}); radarBlipsContainer.innerHTML = bHTML; radarBlips = radarBlips.filter(b => b.life > 0); }
   
    // NEW: Functions for animating the rotate device screen
    function initRotateScreen() {
        rotateScreenCanvas = document.getElementById('rotate-screen-canvas');
        if (!rotateScreenCanvas) return;
        rotateScreenCtx = rotateScreenCanvas.getContext('2d');
        
        rotateScreenCanvas.width = window.innerWidth;
        rotateScreenCanvas.height = window.innerHeight;

        rotateScreenStars = [];
        for (let i = 0; i < ROTATE_STAR_COUNT; i++) {
            rotateScreenStars.push({
                x: Math.random() * rotateScreenCanvas.width,
                y: Math.random() * rotateScreenCanvas.height,
                radius: Math.random() * 1.5,
                alpha: 0.5 + Math.random() * 0.5
            });
        }

        rotateScreenShootingStars = [];
        for (let i = 0; i < ROTATE_SHOOTING_STAR_COUNT; i++) {
            const shootingStar = {
                reset: function() {
                    this.x = Math.random() * rotateScreenCanvas.width;
                    this.y = -20;
                    this.len = Math.random() * 80 + 10;
                    this.speed = Math.random() * 8 + 4;
                    this.alpha = 1;
                }
            };
            shootingStar.reset();
            rotateScreenShootingStars.push(shootingStar);
        }
    }

    function animateRotateScreen() {
        if(!rotateScreenCtx) return;
        rotateScreenCtx.clearRect(0, 0, rotateScreenCanvas.width, rotateScreenCanvas.height);
        
        rotateScreenCtx.fillStyle = '#FFFFFF';
        rotateScreenStars.forEach(star => {
            star.alpha += (Math.random() - 0.5) * 0.05;
            if (star.alpha > 1) star.alpha = 1;
            if (star.alpha < 0.2) star.alpha = 0.2;
            
            rotateScreenCtx.globalAlpha = star.alpha;
            rotateScreenCtx.beginPath();
            rotateScreenCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            rotateScreenCtx.fill();
        });
        rotateScreenCtx.globalAlpha = 1;

        rotateScreenShootingStars.forEach(star => {
            star.x += star.speed;
            star.y += star.speed;

            if(star.x > rotateScreenCanvas.width + star.len || star.y > rotateScreenCanvas.height + star.len) {
                star.reset();
            }

            const gradient = rotateScreenCtx.createLinearGradient(star.x, star.y, star.x - star.len, star.y - star.len);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${star.alpha})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            rotateScreenCtx.strokeStyle = gradient;
            rotateScreenCtx.lineWidth = 2;
            rotateScreenCtx.beginPath();
            rotateScreenCtx.moveTo(star.x, star.y);
            rotateScreenCtx.lineTo(star.x - star.len, star.y - star.len);
            rotateScreenCtx.stroke();
        });

        rotateScreenAnimationId = requestAnimationFrame(animateRotateScreen);
    }
   
    const joystickContainer= document.getElementById('joystick-container'), joystickKnob = document.getElementById('joystick-knob');
    let joystickActiveId = null;
    function handleAim(clientX, clientY) {
        if (isGameOver || isPaused || startScreen.style.display === 'flex' || howToPlayScreen.style.display === 'flex' || levelStartScreen.style.display === 'flex') return;
        joystickTargetPos.active = false; // Mouse movement overrides joystick
        const rect = canvas.getBoundingClientRect();
        
        let relativeX = clientX - rect.left;
        let relativeY = clientY - rect.top;

        // Clamp crosshair position to within the cockpit frame
        const minX = COCKPIT_BORDER_LEFT;
        const maxX = canvas.width - COCKPIT_BORDER_RIGHT;
        const minY = COCKPIT_BORDER_TOP;
        const maxY = canvas.height - COCKPIT_BORDER_BOTTOM;

        crosshairTarget.x = Math.max(minX, Math.min(relativeX, maxX));
        crosshairTarget.y = Math.max(minY, Math.min(relativeY, maxY));
        crosshairPos.x = crosshairTarget.x; // Mouse is instant, no easing
        crosshairPos.y = crosshairTarget.y;
    }
    function handleJoystickMove(e) {
        e.preventDefault(); let touch = null;
        if(joystickActiveId === null) return;
        for (let i = 0; i < e.touches.length; i++) { if (e.touches[i].identifier === joystickActiveId) { touch = e.touches[i]; break; } }
        if (!touch) return;
        const rect = joystickContainer.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2;
        let dx = touch.clientX - centerX; let dy = touch.clientY - centerY;
        const maxDist = (rect.width / 2) - (joystickKnob.offsetWidth / 2);
        const dist = Math.hypot(dx, dy);
        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
        joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

        const gameRect = canvas.getBoundingClientRect();
        let aimX = (gameRect.width / 2) + (dx / maxDist) * (gameRect.width / 2);
        let aimY = (gameRect.height / 2) + (dy / maxDist) * (gameRect.height / 2);
        
        // Clamp to cockpit frame
        const minX = COCKPIT_BORDER_LEFT;
        const maxX = canvas.width - COCKPIT_BORDER_RIGHT;
        const minY = COCKPIT_BORDER_TOP;
        const maxY = canvas.height - COCKPIT_BORDER_BOTTOM;

        crosshairTarget.x = Math.max(minX, Math.min(aimX, maxX));
        crosshairTarget.y = Math.max(minY, Math.min(aimY, maxY));
    }
    function handleJoystickEnd(e) {
        if(joystickActiveId === null) return;
        let touchEnded = false;
        for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joystickActiveId) { touchEnded = true; break; } }
        if (!touchEnded) return;
       
        joystickActiveId = null;
        joystickTargetPos.active = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Snap crosshair back to center
        crosshairTarget.x = canvas.width / 2;
        crosshairTarget.y = canvas.height / 2;
        crosshairPos.x = canvas.width / 2;
        crosshairPos.y = canvas.height / 2;

        window.removeEventListener('touchmove', handleJoystickMove);
        window.removeEventListener('touchend', handleJoystickEnd);
        window.removeEventListener('touchcancel', handleJoystickEnd);
    }
    function handleJoystickStart(e) {
        e.preventDefault();
        if (joystickActiveId === null) {
            joystickTargetPos.active = true;
            const touch = e.changedTouches[0];
            joystickActiveId = touch.identifier;
            window.addEventListener('touchmove', handleJoystickMove, { passive: false });
            window.addEventListener('touchend', handleJoystickEnd, { passive: false });
            window.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
        }
    }

    let canFire = true;
    function fireProjectile() {
        if (!canFire || isGameOver || isPaused || startScreen.style.display === 'flex' || levelStartScreen.style.display === 'flex') return;
        canFire = false;
        const speed = 25;

        // Use the smoothed position for firing
        const startScale = FOCAL_LENGTH / (FOCAL_LENGTH + 0);
        const startX = (crosshairPos.x - canvas.width / 2) / startScale + camera.x;
        const startY = (crosshairPos.y - canvas.height / 2) / startScale + camera.y;
       
        const endScale = FOCAL_LENGTH / (FOCAL_LENGTH + MAX_DEPTH);
        const endX = (crosshairPos.x - canvas.width / 2) / endScale + camera.x;
        const endY = (crosshairPos.y - canvas.height / 2) / endScale + camera.y;
       
        const dx = endX - startX;
        const dy = endY - startY;
        const dz = MAX_DEPTH;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const vel = { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed };
       
        let fireRate = 300;
        let doubleBlasterRate = 150;
        const novaCutterRate = 100;

        if (currentLevel === 4) { // Survival Mode faster fire rate
            fireRate = 150;
            doubleBlasterRate = 75;
        }

        if (player.isNovaCutterActive){
            playSound('shoot_nova');
            projectiles.push(new Projectile(startX, startY, 0, 5, vel, '#FFFFFF', 3));
            setTimeout(() => { canFire = true; }, novaCutterRate);
        } else if (player.isDoubleBlasterActive) {
            playSound('shoot');
            projectiles.push(new Projectile(startX - 20, startY, 0, 3, vel, '#FFA500', 1));
            projectiles.push(new Projectile(startX + 20, startY, 0, 3, vel, '#FFA500', 1));
            setTimeout(() => { canFire = true; }, doubleBlasterRate);
        } else {
            playSound('shoot');
            projectiles.push(new Projectile(startX, startY, 0, 3, vel, '#FFFF00', 1));
            setTimeout(() => { canFire = true; }, fireRate);
        }
    }

    function togglePause() {
        const isGameRunning = !isGameOver && startScreen.style.display === 'none' && levelStartScreen.style.display === 'none' && howToPlayScreen.style.display === 'none';
        if (!isGameRunning) return;

        isPaused = !isPaused;
        if (isPaused) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
            clearInterval(enemySpawner);
            clearInterval(speedIncreaseInterval);
            speedIncreaseInterval = null;
            pauseScreen.style.display = 'flex';
            pauseButton.innerHTML = playIcon;
            animateMenuBackground();
        } else {
            if(menuLoopId) cancelAnimationFrame(menuLoopId);
            menuLoopId = null;
            if (!gameLoopId) animate();
            spawnEnemies();
             if (currentLevel !== 4) {
                speedIncreaseInterval = setInterval(() => {
                    if (!isPaused) dynamicPlayerSpeed += 0.75;
                }, 15000);
             }
            pauseScreen.style.display = 'none';
            pauseButton.innerHTML = pauseIcon;
        }
    }

    function resizeGame() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = 16 / 10;

        let newWidth, newHeight;

        if (viewportWidth / viewportHeight > aspectRatio) {
            newHeight = viewportHeight;
            newWidth = newHeight * aspectRatio;
        } else {
            newWidth = viewportWidth;
            newHeight = newWidth / aspectRatio;
        }

        gameContainer.style.width = `${newWidth}px`;
        gameContainer.style.height = `${newHeight}px`;

        setTimeout(() => {
            const r = gameContainer.getBoundingClientRect();
            if (r.width > 0 && r.height > 0) {
                canvas.width = r.width;
                canvas.height = r.height;
                if (!joystickTargetPos.active) {
                    crosshairPos.x = canvas.width / 2;
                    crosshairPos.y = canvas.height / 2;
                    crosshairTarget.x = canvas.width / 2;
                    crosshairTarget.y = canvas.height / 2;
                }
                ctx.imageSmoothingEnabled = false;
            }
        }, 100);
    }

    let lastOrientation = window.matchMedia("(orientation: landscape)").matches;

    // MODIFIED: Replaced handleOrientationChange with this more robust version
    function checkOrientationAndAnimate() {
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isLandscape = window.matchMedia("(orientation: landscape)").matches;
        
        // Pause game if orientation changes mid-game
        if (isLandscape !== lastOrientation) {
            lastOrientation = isLandscape;
            const isGameActive = !isGameOver && !isPaused && startScreen.style.display === 'none' && levelStartScreen.style.display === 'none' && howToPlayScreen.style.display === 'none';
            if (isGameActive) {
                togglePause();
            }
        }
        
        // Control the rotate screen animation
        if (isTouch && !isLandscape) {
            if (!rotateScreenAnimationId) {
                initRotateScreen();
                animateRotateScreen();
            }
        } else {
            if (rotateScreenAnimationId) {
                cancelAnimationFrame(rotateScreenAnimationId);
                rotateScreenAnimationId = null;
            }
        }
    }

    gameContainer.addEventListener('mousemove', (e) => handleAim(e.clientX, e.clientY));
    gameContainer.addEventListener('mousedown', (e) => { if (e.button === 0) fireProjectile(); });
    joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
    document.getElementById('fireButton').addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); fireProjectile(); }, { passive: false});
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); fireProjectile(); }
        if (e.code === 'KeyP') { togglePause(); }
    });
   
    document.getElementById('sound-toggle').parentElement.addEventListener('click', () => { soundEnabled = !soundEnabled; soundToggle.innerHTML = soundEnabled ? soundOnIcon : soundOffIcon; if (soundEnabled) unlockAudio()});
    pauseButton.parentElement.addEventListener('click', togglePause);
    resumeButton.addEventListener('click', togglePause);
   
    restartButton.addEventListener('click', () => { unlockAudio(); playSound('ui_confirm'); init()});
    levelStartButton.addEventListener('click', startGameLoop);
    mainStartButton.addEventListener('click', () => { unlockAudio(); playSound('ui_confirm'); startScreen.style.display = 'none'; showLevelStartScreen()});
    howToPlayButton.addEventListener('click', () => { unlockAudio(); playSound('ui_confirm'); startScreen.style.display = 'none'; howToPlayScreen.style.display = 'flex'; animateMenuBackground() });
    backToMenuButton.addEventListener('click', () => { unlockAudio(); playSound('ui_confirm'); howToPlayScreen.style.display = 'none'; startScreen.style.display = 'flex'; animateMenuBackground() });
    
    // MODIFIED: Add/update event listeners
    window.addEventListener('resize', () => {
        resizeGame();
        checkOrientationAndAnimate();
    });
    window.addEventListener('orientationchange', checkOrientationAndAnimate);
    
    window.addEventListener('DOMContentLoaded', () => {
        init();
        checkOrientationAndAnimate(); // Initial check on load
    });
    </script>
</body>
</html>
